package SecondWithProgrammingInScala.Chapter5 {

  /**
    * 16进制 表示4位2进制数 0xF = 1111 (4bit)
    * 有符号数第一位是符号位
    *
    * scala使用弱类型表示 ,会根据值自动判断类型
    * 也可以手动指定 类似java
    */
  class BasicType {
    //  字节  8bit的有符号数字，范围在-128 -- 127
    var byte: Byte = 0x01

    //  短整型 16 bit有符号数字，范围在-32768 -- 32767
    var short: Short = 0x0001

    //  整型  32 bit 有符号数字，范围 -2147483648 到 2147483647
    var int = 1

    //  长整型 	64 bit 有符号数字，范围-9223372036854775808 到 9223372036854775807
    var long = 0x09871245

    //  字符 	16 bit Unicode字符. 范围  U+0000 到 U+FFFF
    var char = 'A'

    /**
      * IEEE 754 标准 : 浮点数 = (符号位) 1.尾数 * (2'指数)
      *
      * 符号位 :0+ 1-
      * 阶码(指数) :使用偏移码 ,实际=无符号数-有符号最大值 ,例如8位指数
      * 254(11111110) - 127(0 1111111) = 127(max)
      * 1(00000001) - 127(0 1111111) = -126(min)
      * 尾数 :小数点后有效数字
      * 阶码=0时 ,[尾数=0表示 0] [尾数!=0为 非规格数],
      * 阶码=255时 ,[尾数=0表示 无穷大] [尾数!=0为 NaN非数值],
      *
      * 例: 十进制数 100.25
      * 二进制 -> (1100100.01)
      * 规格化 -> (1.10010001 * 2'6)
      * 阶码偏移 -> 6 + 127 = 133
      * 阶码二进制 -> 10000101
      * 尾数补齐 -> 1001 0001 0000 0000 0000 000
      * 加上符号位生成浮点形式 -> 0 10000101 1001 0001 0000 0000 0000 000
      */
    /**
      * 以上为规格数 ,非规格数即精度超过阶码描述范围(2'-126)
      * 此时,阶码默认为特定最小值0 ,阶码精度默认为 -126
      * 尾数部分 ,以第一个不为零的有效数字算起 ,最大
      *
      * 例:0 00000000 0000 0001 0000 0000 0000 000
      * 提取阶码 -> 0
      * 是非规格数 阶码反偏移 -> -126
      * 判定尾数 -> 0000 0001 0000 0000 0000 000
      * 判定符号位 -> 2'-126 * 0.0000 0001
      * 结果 -> 2'-126 * 2'-8 * 1
      *
      * 规格数最小精度     2'-126 * (1.[0000 0000 0000 0000 0000 000])
      * 非规格数最大精度  2'-126 * (0.[1111 1111 1111 1111 1111 111])
      */
    //  浮点数 	32 bit
    //  1符号位 + 8指数位 + 23尾数位
    //  指数[-126,127]  尾数[2^23 = 8388608] 相对于十进制来说 7位有效数字(有最大界限) 能保证的为6位
    var float = 3.22

    //  双精度浮点数 	64 bit
    // 1符号位 + 11指数位 + 52尾数位
    //  指数[-1022,1023]  尾数[2^52 = 4503599627370496] 相对于十进制来说 16位有效数字(有最大界限) 能保证的为15位
    var double = 3.22

    //  字符串
    var string = "abc"

    //  布尔类型
    var boolean = true

    //  Unit 	表示无值，和其他语言中void等同
    var unit = Unit

    //  Null 	空值或者空引用
    var Null = null

    //  AnyRef 	所有引用类型的超类
    var anyRef = AnyRef

    //  Nothing 	所有其他类型的字类型，表示没有值

    //  Any 	所有类型的超类，任何实例都属于Any类型
  }

  /**
    * 字面量(literal) : 一些简写方式 0xf 十六进制 和Java一致
    * 操作符和方法 : 任何方法都可以作为操作符 只要在调用顺序上不产生歧义
    * 数学运算 : 可以重载运算符
    * 逻辑判断 : >=等
    * 位操作 : 按位与& 按位或| 按位异或
    * 比较对象 : 值1==1.0(true) 对象比较等
    * 运算符优先级 : scala的运算符也是方法 ,以*开头的方法比+开头的优先级高
    * * / %    + -    :    = !    <>    &    &#94;    |    字母    其他操作符
    * 富包装器 : 通过隐式转换调用一些复杂的方法
    */
  object MoreType {
    //操作符
    val s = "Hello"
    s indexOf 'o'
    //富包装 Int 调用 RichInt 的方法
    0 max 5
  }

}